#!/usr/bin/env ruby
require 'etc'
require 'pathname'
require 'set'
require 'socket'
require 'tempfile'

# Declarative package management with dnf!

class Dnf5Keeper
  HOME = Dir.home(Etc.getlogin) # Get user's home dir even if using sudo
  CONFDIR = Pathname.new(HOME).join('.config', 'dnf5keeper')
  PACKAGE_STATE = Pathname.new('/usr/lib/sysimage/libdnf5/packages.toml')

  attr_reader :keepers

  def read_package_list(path)
    return Set.new unless path.file?
    path.readlines
    .map { |l| l.sub(/#.*$/, '').strip }
    .flat_map { |l| l.split(/\s+/) }
    .reject(&:empty?)
    .to_set
  end
  
  def load_reasons
    @by_pkg = {}
    @by_reason = Hash.new { |h, k| h[k] = Set.new }
    IO.popen("dnf repoquery --installed --queryformat '%{name}\#%{reason}\n'")
        .readlines.each do |line|
      line.chomp!
      pkg, reason = line.split('#')
      @by_pkg[pkg] = reason
      @by_reason[reason] << pkg
    end
  end

  def akmods
    # Anything built on current host is likely to be an akmod
    hostname = Socket.gethostname
    IO.popen(['rpm', '-qa', '--qf', '%{NAME}#%{BUILDHOST}\n', 'kmod*'])
        .readlines.flat_map do |line|
      line.chomp!
      pkg, host = line.split('#')
      host == hostname ? [pkg] : []
    end.to_set
  end

  def initialize
    CONFDIR.mkpath
    load_reasons
    @keepers = CONFDIR.children
      .select { |p| p.file? && p.extname == '.keep' }
      .reduce(Set.new) { |ks, p| ks.merge(read_package_list(p)) }
    @keepers += akmods
  end

  def auto
    @auto ||= @by_reason.flat_map { |k,v| k == 'User'? [] : v }.to_set
  end

  def manual
    @by_reason['User']
  end

  def installed
    auto + manual
  end

  def print(pkgs, header = nil)
    puts header if header
    prefix = header ? "  " : ""
    pkgs.sort.each { |p| puts "#{prefix}#{p}" }
  end

  def missing
    @keepers - installed
  end

  def candidates
    manual - @keepers
  end

  def backup(file)
    bak = Pathname.new(file.to_s + '.bak')
    FileUtils.cp(file, bak) if file.file?
  end

  def write_root_keepers
    backup(PACKAGE_STATE)

    new_manual = auto & keepers
    new_auto = manual - keepers
    system('dnf', 'mark', '-y', 'user', *new_manual.to_a, out: :close) if new_manual.any?
    system('dnf', 'mark', '-y', 'dependency', *new_auto.to_a, out: :close) if new_auto.any?
  end

  def add_keepers(basename, reason, packages)
    basename = File.basename(basename, '.keep') # in case user accidentally added .keep
    comment = reason.empty? ? "" : " # #{reason}"
    CONFDIR.join(basename + '.keep').open('a') do |f|
      f.puts "#{packages.join(" ")}#{comment}"
    end
  end

  def external
    @by_reason['External User']
  end
end

ak = Dnf5Keeper.new
orig_argv = ARGV.dup
FORCE_RERUN = ['force']
rerun_root = ->(list, &block) do
  if list.empty?
    $stderr.puts "Nothing to do"
    return 
  end
  if Process.uid == 0
    ak.write_root_keepers
    block[list.sort]
  else
    exec('sudo', __FILE__, *orig_argv)
  end
end

arg = ARGV.shift
case arg
when 'keepers'
  ak.print(ak.keepers)
when 'missing'
  ak.print(ak.missing)
when 'candidates'
  ak.print(ak.candidates)
when 'diff'
  puts "Nothing to do" unless ak.missing.any? || ak.candidates.any?
  ak.print(ak.missing, "To install:") if ak.missing.any?
  ak.print(ak.candidates, "To mark for removal:") if ak.candidates.any?
when 'install'
  rerun_root[ak.missing] { |ps| exec('dnf', 'install', *ps) }
when 'remove'
  # We can't tell if anything is pending autoremove, so force it
  rerun_root[FORCE_RERUN] { exec('dnf', 'autoremove') }
when 'sync'
  rerun_root[FORCE_RERUN] do
    system('dnf', 'install', *ak.missing) if ak.missing.any?
    exec('dnf', 'autoremove')
  end
when 'update-reasons'
  rerun_root[FORCE_RERUN] { }
when 'add'
  basename, reason, *adding = ARGV
  if adding.empty?
    $stderr.puts "Usage: dnf5keeper add BASENAME REASON PACKAGE [PACKAGE...]"
    exit 2
  end
  ak.add_keepers(basename, reason, adding) unless Process.uid == 0
  rerun_root[adding] do |ps|
    exec('dnf', 'install', *ps)
  end
when 'external'
  ak.print(ak.external)
else
  $stderr.puts <<~EOD
    Usage: dnf5keeper [command]
    Commands:
      keepers - list packages in .keep files

      missing - list packages that need installing to match .keep files
      candidates - list top-level packages that need removal
      diff - list packages that need installing or marking for removal

      install - install missing packages
      remove - remove unneeded packages
      sync - install missing and remove unneeded packages
      update-reasons - update dnf reason database

      add REASON PACKAGE ... - add packages to keepers, and install them

      external - identify "external" packages, which should probably be marked otherwise
    EOD
  exit 2
end
